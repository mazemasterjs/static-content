"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Cell_1 = __importDefault(require("./Cell"));
const ObjectBase_1 = require("./ObjectBase");
const MazeLoc_1 = require("./MazeLoc");
const logger_1 = require("@mazemasterjs/logger");
const Enums_1 = require("./Enums");
const log = logger_1.Logger.getInstance();
class MazeBase extends ObjectBase_1.ObjectBase {
    /**
     * Instantiates or new or pre-loaded Maze object
     * @param data - JSON Object containing stubbed maze data
     */
    constructor(jsonData) {
        super();
        this.id = '';
        this.height = 0;
        this.width = 0;
        this.challenge = 0;
        this.name = '';
        this.seed = '';
        this.cells = new Array();
        this.textRender = '';
        this.startCell = new MazeLoc_1.MazeLoc(0, 0);
        this.finishCell = new MazeLoc_1.MazeLoc(0, 0);
        this.shortestPathLength = 0;
        this.trapCount = 0;
        this.note = '';
        this.lastUpdated = Date.now();
        if (jsonData !== undefined) {
            this.loadData(jsonData);
        }
    }
    /**
     * Calculates and returns neighboring cell in the given direction
     * TODO: Consider checking neighbor validity here?
     *
     * @param cell
     * @param dir
     */
    getNeighbor(cell, dir) {
        const method = `getNeighbor(${cell.Location.toString()}, ${Enums_1.DIRS[dir]})`;
        // move location of next cell according to random direction
        let row = cell.Location.row;
        let col = cell.Location.col;
        this.logTrace(__filename, `getNeighbor(${cell.Location.toString()}, ${Enums_1.DIRS[dir]}`, 'Getting neighboring cell.');
        // find coordinates of the cell in the given direction
        if (dir < Enums_1.DIRS.EAST) {
            row = dir === Enums_1.DIRS.NORTH ? row - 1 : row + 1;
        }
        if (dir > Enums_1.DIRS.SOUTH) {
            col = dir === Enums_1.DIRS.EAST ? col + 1 : col - 1;
        }
        // let's throw a warning if an invalid neighbor is returned since we might want to change this some day
        if (row < 0 || row >= this.cells.length || col < 0 || col >= this.cells[0].length) {
            this.logTrace(__filename, method, `Invalid neighbor position: ${row}, ${col}`);
        }
        else {
            this.logTrace(__filename, method, `Neighbor: ${row}, ${col}`);
        }
        return this.getCell(new MazeLoc_1.MazeLoc(row, col));
    }
    /**
     * Attempts to find and return the cell in the given position
     *
     * @param pos
     * @throws Out Of Bounds error if given position is outside of cells array's bounds.
     */
    getCell(pos) {
        if (pos.row < 0 || pos.row >= this.cells.length || pos.col < 0 || pos.col > this.cells[0].length) {
            const error = new Error(`Invalid cell coordinates given: [${pos.toString()}].`);
            log.error(__filename, `getCell${pos.row}, ${pos.col}`, 'Cell range out of bounds, throwing error.', error);
            throw error;
        }
        this.logTrace(__filename, `getCell(${pos.toString()}`, 'Returning cell.');
        return this.cells[pos.row][pos.col];
    }
    /**
     * Returns a text rendering of the maze as a grid of 3x3
     * character blocks.
     */
    // tslint:disable-next-line: no-shadowed-variable
    generateTextRender(forceRegen, playerPos) {
        const H_WALL = '+---';
        const S_DOOR = '+ S ';
        const F_DOOR = '+ F ';
        const V_WALL = '|';
        const H_DOOR = '+   ';
        const V_DOOR = ' ';
        const CENTER = '   ';
        const SOLUTION = ' . ';
        const ROW_END = '+';
        const AVATAR_TRAPPED = '>@<';
        const AVATAR = ' @ ';
        // TODO: Turn back on render caching after solver work is completed
        if (this.textRender.length > 0 && !forceRegen) {
            return this.textRender;
        }
        let textMaze = '';
        // walk the array, one row at a time
        for (let y = 0; y < this.height; y++) {
            for (let subRow = 0; subRow < 3; subRow++) {
                let row = '';
                // each text-cell is actually three
                for (let x = 0; x < this.width; x++) {
                    const cell = this.cells[y][x];
                    switch (subRow) {
                        case 0:
                            // only render north walls on first row
                            if (y === 0) {
                                if (!!(cell.Tags & Enums_1.CELL_TAGS.START)) {
                                    row += S_DOOR;
                                }
                                else {
                                    row += !!(cell.Exits & Enums_1.DIRS.NORTH) ? H_DOOR : H_WALL;
                                }
                            }
                            break;
                        case 1:
                            // only render west walls on first column
                            if (x === 0) {
                                row += !!(cell.Exits & Enums_1.DIRS.WEST) ? V_DOOR : V_WALL;
                            }
                            // render room center - check for cell properties and render appropriately
                            let cellFill = CENTER;
                            const tags = cell.Tags;
                            const traps = cell.Traps;
                            if (!!(tags & Enums_1.CELL_TAGS.PATH)) {
                                cellFill = SOLUTION;
                            }
                            // add a trap icon if one is in this cell
                            if (traps > 0) {
                                cellFill = this.getCellTrapIcon(traps);
                            }
                            // override cell fill with avatar location when player position is given
                            if (playerPos !== undefined && this.cells[y][x].Location.equals(playerPos)) {
                                if (traps !== 0) {
                                    cellFill = AVATAR_TRAPPED;
                                }
                                else {
                                    cellFill = AVATAR;
                                }
                            }
                            row += cellFill;
                            // always render east walls (with room center)
                            row += !!(cell.Exits & Enums_1.DIRS.EAST) ? V_DOOR : V_WALL;
                            break;
                        case 2:
                            // always render south walls
                            if (!!(cell.Tags & Enums_1.CELL_TAGS.FINISH)) {
                                row += F_DOOR;
                            }
                            else {
                                row += !!(cell.Exits & Enums_1.DIRS.SOUTH) ? H_DOOR : H_WALL;
                            }
                            break;
                    }
                }
                if (subRow !== 1) {
                    row += ROW_END;
                }
                // end the line - only draw the top subRow if on the first line
                if ((subRow === 0 && y === 0) || subRow > 0) {
                    textMaze += row + '\n';
                }
            }
        }
        this.textRender = textMaze.toString();
        return textMaze;
    }
    get LastUpdated() {
        return this.lastUpdated;
    }
    set LastUpdated(timestamp) {
        this.lastUpdated = timestamp;
    }
    get Height() {
        return this.height;
    }
    get Width() {
        return this.width;
    }
    get Name() {
        return this.name;
    }
    get Seed() {
        return this.seed;
    }
    get ChallengeLevel() {
        return this.challenge;
    }
    get Cells() {
        return this.cells;
    }
    get CellCount() {
        return this.cells.length * this.cells[0].length;
    }
    get TextRender() {
        return this.textRender;
    }
    get Id() {
        return this.id;
    }
    get StartCell() {
        return this.startCell;
    }
    get FinishCell() {
        return this.finishCell;
    }
    get ShortestPathLength() {
        return this.shortestPathLength;
    }
    get TrapCount() {
        return this.trapCount;
    }
    get Note() {
        return this.note;
    }
    set Note(value) {
        this.note = value;
    }
    /**
     * Validates and loads the given JSON object into the current MazeBase instance
     *
     * @param jsonData
     */
    loadData(jsonData) {
        this.logDebug(__filename, `loadData(${jsonData})`, 'Loading data...');
        if (jsonData !== undefined) {
            this.id = this.validateDataField('id', jsonData.id, 'string');
            this.height = this.validateDataField('height', jsonData.height, 'number');
            this.width = this.validateDataField('width', jsonData.width, 'number');
            this.challenge = this.validateDataField('challenge', jsonData.challenge, 'number');
            this.name = this.validateDataField('name', jsonData.name, 'string');
            this.seed = this.validateDataField('seed', jsonData.seed, 'string');
            this.cells = this.buildCellsArray(this.validateDataField('cells', jsonData.cells, 'array'));
            this.textRender = this.validateDataField('textRender', jsonData.textRender, 'string', true);
            this.startCell = this.validateDataField('startCell', jsonData.startCell, 'object');
            this.finishCell = this.validateDataField('finishCell', jsonData.finishCell, 'object');
            this.shortestPathLength = this.validateDataField('shortestPathLength', jsonData.shortestPathLength, 'number');
            this.trapCount = this.validateDataField('trapCount', jsonData.trapCount, 'number');
            this.note = this.validateDataField('note', jsonData.note, 'string');
            this.lastUpdated = this.validateDataField('lastUpdated', jsonData.lastUpdated, 'number');
            this.logDebug(__filename, `loadData(${jsonData})`, 'Load successful.');
        }
        else {
            log.warn(__filename, `loadData(${jsonData})`, 'Unable to load JSON data into MazeBase object: ' + JSON.stringify(jsonData));
        }
    }
    /**
     * Returns only basic maze data - for use
     * with lists, scores, etc
     */
    getMazeStub() {
        return {
            id: this.id,
            height: this.height,
            width: this.width,
            challenge: this.challenge,
            name: this.name,
            seed: this.seed,
            note: this.note,
            lastUpdated: this.lastUpdated,
        };
    }
    /**
     * Rebuild the maze array from the given data to instantiate
     * each individual Cell object
     * @param cells
     */
    buildCellsArray(cells) {
        this.logTrace(__filename, `buildCellsArray(Array<Array<Cell>>)`, 'Attempting to rebuild cells array from JSON data...');
        const newCells = new Array(this.height);
        for (let row = 0; row < this.height; row++) {
            const cols = new Array();
            for (let col = 0; col < this.width; col++) {
                const cData = JSON.parse(JSON.stringify(cells[row][col]));
                const cell = new Cell_1.default(cData);
                this.logTrace(__filename, 'buildCellsArray(Array<Array<Cell>>)', `Adding cell in position [${row}, ${col}]`);
                cols.push(cell);
            }
            newCells[row] = cols;
        }
        return newCells;
    }
    /**
     * Return appropriate trap icon for text-renderer given
     * a cell.Traps bitwise value.
     *
     * @param cellTraps
     */
    getCellTrapIcon(cellTraps) {
        if (!!(cellTraps & Enums_1.CELL_TRAPS.MOUSETRAP)) {
            return '>m<';
        }
        if (!!(cellTraps & Enums_1.CELL_TRAPS.PIT)) {
            return '>p<';
        }
        if (!!(cellTraps & Enums_1.CELL_TRAPS.FLAMETHROWER)) {
            return '>f<';
        }
        if (!!(cellTraps & Enums_1.CELL_TRAPS.FRAGILE_FLOOR)) {
            return '>F<';
        }
        if (!!(cellTraps & Enums_1.CELL_TRAPS.POISON_DART)) {
            return '>d<';
        }
        if (!!(cellTraps & Enums_1.CELL_TRAPS.TELEPORTER)) {
            return '>T<';
        }
        if (!!(cellTraps & Enums_1.CELL_TRAPS.TARPIT)) {
            return '>t<';
        }
        if (!!(cellTraps & Enums_1.CELL_TRAPS.DEADFALL)) {
            return '>D<';
        }
        if (!!(cellTraps & Enums_1.CELL_TRAPS.CHEESE)) {
            return '>C<';
        }
        return '';
    }
}
exports.MazeBase = MazeBase;
exports.default = MazeBase;
//# sourceMappingURL=MazeBase.js.map