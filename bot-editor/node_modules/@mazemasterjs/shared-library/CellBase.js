"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const Enums_1 = require("./Enums");
const MazeLoc_1 = require("./MazeLoc");
const ObjectBase_1 = require("./ObjectBase");
const logger_1 = require("@mazemasterjs/logger");
const Helpers = __importStar(require("./Helpers"));
// we'll need a logger...
const log = logger_1.Logger.getInstance();
class CellBase extends ObjectBase_1.ObjectBase {
    constructor(jsonData) {
        super();
        log.trace(__filename, 'constructor()', 'Instantiating new CellBase.');
        this.pos = new MazeLoc_1.MazeLoc(0, 0);
        this.exits = Enums_1.DIRS.NONE;
        this.tags = Enums_1.CELL_TAGS.NONE;
        this.traps = Enums_1.CELL_TRAPS.NONE;
        this.visits = 0;
        this.lastVisit = 0;
        this.notes = new Array();
        if (jsonData !== undefined) {
            this.loadData(jsonData);
        }
    }
    loadData(jsonData) {
        log.trace(__filename, `loadData(${jsonData})`, 'Attempting to populate CellBase from jsonData...');
        if (jsonData !== undefined) {
            this.pos = this.validateDataField('pos', jsonData.pos, 'object');
            this.exits = this.validateDataField('exits', jsonData.exits, 'number');
            this.tags = this.validateDataField('tags', jsonData.tags, 'number');
            this.traps = this.validateDataField('traps', jsonData.traps, 'number');
            this.visits = this.validateDataField('visits', jsonData.visits, 'number');
            this.lastVisit = this.validateDataField('lastVisit', jsonData.lastVisit, 'number');
            this.notes = this.validateDataField('notes', jsonData.notes, 'array');
        }
        else {
            log.warn(__filename, `loadData(${jsonData})`, 'Unable to load JSON Data into CellBase: ' + JSON.stringify(jsonData));
        }
    }
    /**
     * Returns the string array containing player-written notes
     */
    get Notes() {
        return this.notes;
    }
    /**
     * Add a string to the CellBase.notes array
     */
    addNote(note) {
        this.notes.push(note);
        log.debug(__filename, 'addNote()', 'Note added to cell: ' + note);
    }
    /**
     * Returns the bitwise exits value for the current cell
     */
    get Exits() {
        return this.exits;
    }
    /**
     * Returns a string listing all available exit directions
     */
    listExits() {
        return Helpers.listSelectedBitNames(Enums_1.DIRS, this.exits);
    }
    /**
     * Returns an array representing the cells grid coordinates (row, col)
     */
    get Location() {
        return new MazeLoc_1.MazeLoc(this.pos.row, this.pos.col);
    }
    /**
     * Set the cell's grid coordinates
     * @param x
     * @param y
     */
    set Location(pos) {
        this.pos = pos;
    }
    /**
     * Returns a bitwise integer value representing cell tags
     */
    get Tags() {
        return this.tags;
    }
    /**
     * Returns the bitwise integer value representing cell traps
     */
    get Traps() {
        return this.traps;
    }
    /**
     * Returns list of string values representing cell tags
     */
    listTags() {
        return Helpers.listSelectedBitNames(Enums_1.CELL_TAGS, this.tags);
    }
    /**
     *  Increment the cell's visits counter by one and update lastVisit moveNumber
     */
    addVisit(moveNumber) {
        this.visits++;
        this.lastVisit = moveNumber;
    }
    /**
     * Returns the number of times the cell has been visited
     */
    get VisitCount() {
        return this.visits;
    }
    /**
     * Returns the move number that the cell was last visited on, 0 if never visited.
     */
    get LastVisited() {
        return this.lastVisit;
    }
    /**
     * Returns true if the cell has an exit in the given direction, otherwise... returns !true
     *
     * @param dir - Direction to check for an exit
     * @returns boolean
     */
    isDirOpen(dir) {
        return !!(this.Exits & dir);
    }
}
exports.CellBase = CellBase;
exports.default = CellBase;
//# sourceMappingURL=CellBase.js.map