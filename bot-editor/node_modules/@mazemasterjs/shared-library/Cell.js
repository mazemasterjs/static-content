"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Helpers = __importStar(require("./Helpers"));
const Enums_1 = require("./Enums");
const logger_1 = require("@mazemasterjs/logger");
const MazeLoc_1 = require("./MazeLoc");
const CellBase_1 = __importDefault(require("./CellBase"));
/**
 * Used to determine mode of functions modifying cell exits
 */
var FN_MODES;
(function (FN_MODES) {
    FN_MODES[FN_MODES["ADD"] = 0] = "ADD";
    FN_MODES[FN_MODES["REMOVE"] = 1] = "REMOVE";
})(FN_MODES || (FN_MODES = {}));
const log = logger_1.Logger.getInstance();
/**
 * Represents a single cell in a maze
 */
class Cell extends CellBase_1.default {
    constructor(jsonData) {
        super();
        if (jsonData !== undefined) {
            this.loadData(jsonData);
        }
    }
    /**
     * Adds the given trap to the cell (unless it's already been set)
     *
     * @param trap - A value from Enums.CELL_TRAPS
     */
    addTrap(trap) {
        if (!!(this.traps & trap)) {
            this.logTrace(__filename, `addTrap(${trap})`, `${Enums_1.CELL_TRAPS[trap]} (${trap}) already set in cell [${this.pos.toString()}]. Current traps: ${Helpers.listSelectedBitNames(Enums_1.CELL_TRAPS, this.traps)}`);
        }
        else {
            this.traps += trap;
            this.logTrace(__filename, `addTrap(${trap})`, `${Enums_1.CELL_TRAPS[trap]} (${trap}) added to cell [${this.pos.toString()}].`);
        }
    }
    /**
     * Removes the given trap to the cell (unless it's not found)
     *
     * @param trap - A value from Enums.CELL_TRAPS
     */
    removeTrap(trap) {
        if (!!(this.traps && Enums_1.CELL_TRAPS)) {
            this.traps -= trap;
            this.logTrace(__filename, `removeTrap(${trap})`, `${Enums_1.CELL_TRAPS[trap]} (${trap}) removed from cell [${this.pos.toString()}]. Traps left: ${Helpers.listSelectedBitNames(Enums_1.CELL_TRAPS, this.traps)}`);
        }
        else {
            this.logTrace(__filename, `removeTrap(${trap})`, `${Enums_1.CELL_TRAPS[trap]} (${trap}) not found in cell [${this.pos.toString()}]. Current traps: ${Helpers.listSelectedBitNames(Enums_1.CELL_TRAPS, this.traps)}`);
        }
    }
    /**
     * Remove all traps
     */
    clearTraps() {
        this.traps = Enums_1.CELL_TRAPS.NONE;
    }
    /**
     * Adds an Enums.Tag to this cell if it doesn't already exist
     * @param tag
     */
    addTag(tag) {
        const tagName = Enums_1.CELL_TAGS[tag];
        if (!(this.tags & tag)) {
            this.tags += tag;
            switch (tag) {
                case Enums_1.CELL_TAGS.START:
                    // force north exit on start cell - WARNING: do NOT use addExit() for this!
                    if (!(this.exits & Enums_1.DIRS.NORTH)) {
                        this.logTrace(__filename, 'addTag(' + tagName + ')', `[${this.pos.row}, ${this.pos.col}] has ${tagName} tag. Forcing NORTH exit through edge. Cell exits: ${this.listExits()}`);
                        this.exits += Enums_1.DIRS.NORTH;
                    }
                    break;
                case Enums_1.CELL_TAGS.FINISH:
                    // force south exit on finish cell - WARNING: do NOT use addExit() for this, either!
                    if (!(this.exits & Enums_1.DIRS.SOUTH)) {
                        this.logTrace(__filename, 'addTag(' + tagName + ')', `[${this.pos.row}, ${this.pos.col}] has ${tagName} tag. Forcing SOUTH exit through edge. Cell exits: ${this.listExits()}`);
                        this.exits += Enums_1.DIRS.SOUTH;
                    }
                    break;
            }
            this.logTrace(__filename, 'addTag(' + tagName + ')', `Tag ${tagName} added to cell [${this.pos.row}, ${this.pos.col}]. Current tags: ${this.listTags()}.`);
        }
        else {
            log.warn(__filename, 'addTag(' + tagName + ')', `Tag ${tagName} already exists in cell [${this.pos.row}, ${this.pos.col}]. Current tags: ${this.listTags()}.`);
        }
    }
    /**
     * Removes a tag from this cell, if it exists
     * @param tag
     */
    removeTag(tag) {
        const tagName = Enums_1.CELL_TAGS[tag];
        if (!!(this.tags & tag)) {
            this.tags -= tag;
            this.logTrace(__filename, 'removeTag(' + tagName + ')', `Tag ${tagName} removed from cell [${this.pos.row}, ${this.pos.col}]. Current tags: ${this.listTags()}.`);
        }
        else {
            log.warn(__filename, 'removeTag(' + tagName + ')', `Tag ${tagName} not found in cell [${this.pos.row}, ${this.pos.col}]. Current tags: ${this.listTags()}.`);
        }
    }
    /**
     * Removes all cell tags.
     */
    clearTags() {
        this.tags = Enums_1.CELL_TAGS.NONE;
    }
    /**
     * Return a count of exits available in this cell
     */
    getExitCount() {
        return Helpers.getSelectedBitNames(Enums_1.DIRS, this.exits).length;
    }
    /**
     * Adds exit to a cell if exit doesn't already exist.
     * Also adds neighboring exit to valid, adjoining cell.
     *
     * @param dir
     * @param cells
     * @returns boolean
     */
    addExit(dir, cells) {
        this.logTrace(__filename, `addExit(${Enums_1.DIRS[dir]})`, `Calling setExit(ADD, ${Enums_1.DIRS[dir]}) from [${this.pos.toString()}]. Existing exits: ${this.listExits()}`);
        return this.setExit(FN_MODES.ADD, dir, cells);
    }
    /**
     * Removes exit to a cell if it exists.
     * Also removes neighboring exit from valid, adjoining cell.
     *
     * @param dir
     * @param cells
     * @returns boolean
     */
    removeExit(dir, cells) {
        this.logTrace(__filename, `removeExit(${Enums_1.DIRS[dir]})`, `Calling setExit(REMOVE, ${Enums_1.DIRS[dir]}) from [${this.pos.toString()}]. Existing exits: ${this.listExits()}`);
        return this.setExit(FN_MODES.REMOVE, dir, cells);
    }
    /**
     * Adds or Removes cell exits, depending on SET_EXIT_MODES value.
     * Also adds or removes opposite exit from valid, adjoining cell.
     * Only trace logging - this is called frequently by recursive generation
     * routines.
     *
     * @param dir
     * @param cells
     * @returns boolean
     */
    setExit(mode, dir, cells) {
        const modeName = mode === FN_MODES.ADD ? 'ADD' : 'REMOVE';
        const dirName = Enums_1.DIRS[dir];
        let validMove = true; // only set to true if valid adjoining cell exits to open an exit to
        this.logTrace(__filename, `setExit(${modeName}, ${dirName})`, `Setting exits in [${this.pos.toString()}]. Existing exits: ${this.listExits()}.`);
        if (mode === FN_MODES.ADD ? !(this.exits & dir) : !!(this.exits & dir)) {
            let nPos = new MazeLoc_1.MazeLoc(-1, -1); // locate an adjoining cell - must open exit on both sides
            switch (dir) {
                case Enums_1.DIRS.NORTH:
                    validMove = this.pos.row > 0;
                    if (validMove) {
                        nPos = new MazeLoc_1.MazeLoc(this.pos.row - 1, this.pos.col);
                    }
                    break;
                case Enums_1.DIRS.SOUTH:
                    validMove = this.pos.row < cells.length;
                    if (validMove) {
                        nPos = new MazeLoc_1.MazeLoc(this.pos.row + 1, this.pos.col);
                    }
                    break;
                case Enums_1.DIRS.EAST:
                    validMove = this.pos.col < cells[0].length;
                    if (validMove) {
                        nPos = new MazeLoc_1.MazeLoc(this.pos.row, this.pos.col + 1);
                    }
                    break;
                case Enums_1.DIRS.WEST:
                    validMove = this.pos.col > 0;
                    if (validMove) {
                        nPos = new MazeLoc_1.MazeLoc(this.pos.row, this.pos.col - 1);
                    }
                    break;
            }
            if (validMove) {
                this.logTrace(__filename, 'setExit()', `Valid direction, setting exit from [${this.Location.toString()}] into [${nPos.row}, ${nPos.col}]`);
                this.exits = mode === FN_MODES.ADD ? (this.exits += dir) : (this.exits -= dir);
                const neighbor = cells[nPos.row][nPos.col];
                this.logTrace(__filename, `setExit(${modeName}, ${dirName})`, `Exits set in cell [${this.pos.toString()}]. Existing exits: ${this.listExits()}.`);
                neighbor.exits = mode === FN_MODES.ADD ? (neighbor.exits += Helpers.reverseDir(dir)) : (neighbor.exits -= dir);
                this.logTrace(__filename, `setExit(${modeName}, ${dirName})`, `Reverse exit (${dirName} -> ${Enums_1.DIRS[Helpers.reverseDir(dir)]}) set in adjoining cell [${neighbor.pos.toString()}]. Exits: ${neighbor.listExits()}, Tags: ${neighbor.listTags()}.`);
            }
            else {
                log.warn(__filename, `setExit(${modeName}, ${dirName})`, `Invalid adjoining cell location: [${nPos.toString()}]`);
            }
        }
        else {
            log.warn(__filename, `setExit(${modeName}, ${dirName})`, `Invalid action in cell [${this.pos.toString()}]. Exit ${mode === FN_MODES.ADD ? 'already exists' : 'not found'}. Cell exits: ${this.listExits()}`);
        }
        return validMove;
    } // setExit
}
exports.Cell = Cell;
exports.default = Cell;
//# sourceMappingURL=Cell.js.map