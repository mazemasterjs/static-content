"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Enums_1 = require("./Enums");
const Score_1 = require("./Score");
const logger_1 = require("@mazemasterjs/logger");
const Player_1 = require("./Player");
const ObjectBase_1 = require("./ObjectBase");
const MazeLoc_1 = __importDefault(require("./MazeLoc"));
const log = logger_1.Logger.getInstance();
class Game extends ObjectBase_1.ObjectBase {
    constructor(maze, teamId, botId) {
        super();
        this.id = this.generateId();
        this.state = Enums_1.GAME_STATES.NEW;
        this.maze = maze;
        this.player = new Player_1.Player(new MazeLoc_1.default(maze.StartCell.row, maze.StartCell.col), Enums_1.PLAYER_STATES.SITTING, Enums_1.DIRS.SOUTH);
        this.actions = new Array();
        this.lastAccessed = Date.now();
        this.round = 1;
        this.mode = Enums_1.GAME_MODES.SINGLE_PLAYER;
        this.teamId = teamId.trim();
        this.botId = botId ? botId : '';
        this.score = new Score_1.Score(this.id, maze.Id, this.teamId, this.mode, this.botId);
        // teamId is always required
        if (teamId === '') {
            const err = new Error('Invalid teamId recieved: ' + teamId);
            log.error(__filename, 'constructor()', 'Invalid Parameter ->', err);
            throw err;
        }
        // validate bot if singleplayer game
        this.botId = this.botId.trim();
        if (botId !== '') {
            log.debug(__filename, 'constructor()', 'botId provided - game is singleplayer.');
            this.mode = Enums_1.GAME_MODES.MULTI_PLAYER;
        }
        else {
            log.debug(__filename, 'constructor()', 'No botId was provided - game is multiplayer.');
        }
    }
    get Round() {
        this.lastAccessed = Date.now();
        return this.round;
    }
    get LastAccessTime() {
        this.lastAccessed = Date.now();
        return this.lastAccessed;
    }
    get Id() {
        this.lastAccessed = Date.now();
        return this.id;
    }
    get BotId() {
        this.lastAccessed = Date.now();
        return this.botId;
    }
    addAction(action) {
        if (this.state === Enums_1.GAME_STATES.NEW) {
            this.State = Enums_1.GAME_STATES.IN_PROGRESS;
        }
        this.lastAccessed = Date.now();
        this.actions.push(action);
    }
    getLastAction() {
        this.lastAccessed = Date.now();
        if (this.actions.length === 0) {
            const actError = new Error('The game has no actions to return.');
            log.error(__filename, 'getLastAction()', 'Cannot return lastAction ->', actError);
            throw actError;
        }
        return this.actions[this.actions.length - 1];
    }
    getAction(moveNumber) {
        this.lastAccessed = Date.now();
        return this.actions[moveNumber];
    }
    get Actions() {
        this.lastAccessed = Date.now();
        return this.actions;
    }
    /**
     * Returns a list of actions starting with the given move number
     *
     * @param moveNumber - First move in the returned list of actions
     *
     */
    getActionsSince(moveNumber) {
        this.lastAccessed = Date.now();
        const ret = new Array();
        moveNumber--;
        if (moveNumber < 0) {
            moveNumber = 0;
        }
        if (moveNumber >= this.actions.length) {
            moveNumber = this.actions.length - 1;
        }
        for (let x = moveNumber; x < this.actions.length; x++) {
            ret.push(this.actions[x]);
        }
        return ret;
    }
    /**
     * Returns an array of game actions within the given range
     *
     * @param start starting action
     * @param count total number of actions to return
     */
    getActionsRange(start, count) {
        this.lastAccessed = Date.now();
        const actions = new Array();
        if (start < 1) {
            start = 1;
        }
        if (count < 1) {
            count = 1;
        }
        start = start - 1;
        for (start; start < count; start++) {
            if (start <= this.actions.length) {
                actions.push(this.actions[start]);
            }
        }
        return actions;
    }
    // no last access check here because this method is used by cache manager
    getStub(gameServerExtUrl) {
        return {
            botId: this.BotId,
            gameId: this.Id,
            gameMode: this.Mode,
            gameState: this.State,
            mazeStub: this.Maze.getMazeStub(),
            score: this.Score,
            teamId: this.TeamId,
            url: `${gameServerExtUrl}${this.Id}`,
        };
    }
    // useful for testing - forces the Game ID to the given value
    forceSetId(forcedId) {
        this.lastAccessed = Date.now();
        this.id = forcedId;
        this.score.GameId = this.id;
    }
    // returns game mode: single or multiplayer
    get Mode() {
        this.lastAccessed = Date.now();
        return this.mode;
    }
    get State() {
        this.lastAccessed = Date.now();
        // no last access update here because this function is used by cache manager
        return this.state;
    }
    set State(gameState) {
        this.lastAccessed = Date.now();
        this.state = gameState;
        // update the score GAME_RESULT value as well
        switch (gameState) {
            case Enums_1.GAME_STATES.IN_PROGRESS: {
                this.score.GameResult = Enums_1.GAME_RESULTS.IN_PROGRESS;
                return;
            }
            case Enums_1.GAME_STATES.ABORTED:
            case Enums_1.GAME_STATES.ERROR: {
                this.score.GameResult = Enums_1.GAME_RESULTS.ABANDONED;
                return;
            }
        }
    }
    get Maze() {
        this.lastAccessed = Date.now();
        return this.maze;
    }
    get TeamId() {
        this.lastAccessed = Date.now();
        return this.teamId;
    }
    get Score() {
        this.lastAccessed = Date.now();
        return this.score;
    }
    get Player() {
        this.lastAccessed = Date.now();
        return this.player;
    }
    set Player(player) {
        this.player = player;
    }
}
exports.Game = Game;
//# sourceMappingURL=Game.js.map