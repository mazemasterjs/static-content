"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const Endpoint_1 = require("./Endpoint");
const logger_1 = require("@mazemasterjs/logger");
const Argument_1 = __importDefault(require("./Argument"));
// grab a reference to the logger
const log = logger_1.Logger.getInstance();
/**
 * Service class loads and wraps the service.json file - currently just for self-documentastion,
 * but may be useful for test automation and service discovery at some point in the future.
 */
class Service {
    /**
     *
     * @param serviceFile Path and filename of the service.json file to load
     */
    constructor(serviceFile) {
        this.name = '';
        this.baseUrl = '';
        this.endpoints = new Array();
        if (serviceFile !== undefined && serviceFile !== '') {
            if (!fs_1.default || !fs_1.default.readFileSync) {
                log.warn(__filename, `loadServiceData(${serviceFile}`, 'Cannot access fs module.');
                return;
            }
            if (!fs_1.default.existsSync(serviceFile)) {
                const err = new Error(`FILE NOT FOUND: ${serviceFile}`);
                logger_1.Logger.getInstance().error(__filename, `constructor(${serviceFile})`, '', err);
                throw err;
            }
            this.loadServiceData(serviceFile);
        }
    }
    /**
     * Loads the service directly from the given JSON data object
     */
    loadFromJson(svcData) {
        let error = new Error();
        if (typeof svcData.name !== 'string' || svcData.name.trim() === '') {
            error = new Error('Service.name must be a string.');
        }
        if (typeof svcData.baseUrl !== 'string' || svcData.baseUrl.trim() === '') {
            error = new Error('Service.baseUrl must be a string.');
        }
        if (error.message !== '') {
            log.error(__filename, `loadFromJson(${svcData})`, 'Cannot parse svcData ->', error);
            throw error;
        }
        this.name = svcData.name;
        this.baseUrl = svcData.baseUrl;
        this.endpoints = new Array();
        /* istanbul ignore if */
        if (svcData.endpoints) {
            for (const ep of svcData.endpoints) {
                const newEp = new Endpoint_1.Endpoint(ep);
                for (const arg of ep.arguments) {
                    newEp.addArgument(new Argument_1.default(arg));
                }
                this.endpoints.push(newEp);
            }
        }
    }
    addEndpoint(endpoint) {
        this.endpoints.push(endpoint);
    }
    getEndpointByName(name) {
        for (const ep of this.Endpoints) {
            log.trace(__filename, `getEndpointByName('${name}')`, 'Checking EP: ' + ep.Name);
            if (ep.Name === name) {
                log.debug(__filename, `getEndpointByName('${name}')`, 'Endpoint found, returning.');
                return ep;
            }
        }
        log.warn(__filename, `getEndpointByName('${name})'`, 'Endpoint not found, returning null.');
        return null;
    }
    /**
     * Attempts to read the service document (JSON) from the given file name/path.
     *
     * @param serviceFile - File name and path to the service document (JSON) data file.
     */
    loadServiceData(serviceFile) {
        let svcData;
        if (!fs_1.default || !fs_1.default.readFileSync) {
            log.warn(__filename, `loadServiceData(${serviceFile}`, 'Cannot access fs module.');
            return;
        }
        try {
            svcData = JSON.parse(fs_1.default.readFileSync(serviceFile, { encoding: 'utf8' }));
            log.debug(__filename, `loadServiceData(${serviceFile})`, `JSON file parsed, Service.Name=${svcData.name}`);
            if (svcData !== undefined) {
                this.name = svcData.name;
                this.baseUrl = svcData.baseUrl;
                for (const ep of svcData.endpoints) {
                    const newEp = new Endpoint_1.Endpoint(ep);
                    for (const arg of ep.arguments) {
                        newEp.addArgument(new Argument_1.default(arg));
                    }
                    this.endpoints.push(newEp);
                }
            }
        }
        catch (err) {
            log.error(__filename, `loadServiceData(${serviceFile})`, `Unable parse JSON file`, err);
        }
    }
    get Name() {
        return this.name;
    }
    get BaseUrl() {
        return this.baseUrl;
    }
    get Endpoints() {
        return this.endpoints;
    }
}
exports.Service = Service;
exports.default = Service;
//# sourceMappingURL=Service.js.map